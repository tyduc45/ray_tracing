#version 460

layout (local_size_x = 8, local_size_y = 8) in;

// 输出图像（和 C++ 里 binding = 0 对应）
layout (rgba32f, binding = 0) uniform image2D uOutput;

// 屏幕尺寸 & 相机
uniform int uWidth;
uniform int uHeight;
uniform int uFrame;
uniform int uSphereCount;

uniform vec3 uCamPos;
uniform vec3 uCamForward;
uniform vec3 uCamRight;
uniform vec3 uCamUp;
uniform float uFov;

// 场景中的球体（std430, binding = 0）
struct Sphere
{
    vec4 centerRadius;   // xyz = center, w = radius
    vec4 colorEmission;  // xyz = color, w = emission
};

layout(std430, binding = 0) buffer SpheresBuffer
{
    Sphere spheres[];
};

// 简单 Ray 结构
struct Ray
{
    vec3 origin;
    vec3 dir;
};

// 命中信息
struct HitInfo
{
    float t;
    int   index;
    vec3  normal;
};

// Ray-Sphere 求交
bool intersectSphere(Ray ray, Sphere s, out HitInfo hit)
{
    vec3 center = s.centerRadius.xyz;
    float radius = s.centerRadius.w;

    vec3 oc = ray.origin - center;
    float a = dot(ray.dir, ray.dir);
    float b = 2.0 * dot(oc, ray.dir);
    float c = dot(oc, oc) - radius * radius;

    float disc = b * b - 4.0 * a * c;
    if (disc < 0.0)
        return false;

    float sqrtDisc = sqrt(disc);
    float t1 = (-b - sqrtDisc) / (2.0 * a);
    float t2 = (-b + sqrtDisc) / (2.0 * a);

    float t = 1e20;
    if (t1 > 0.001 && t1 < t) t = t1;
    if (t2 > 0.001 && t2 < t) t = t2;
    if (t == 1e20)
        return false;

    hit.t = t;
    vec3 p = ray.origin + t * ray.dir;
    hit.normal = normalize(p - center);
    return true;
}

// 简单随机数（hash-based）—— 可以用来后面做抖动/抗锯齿
float rand(inout uint state)
{
    state ^= state << 13;
    state ^= state >> 17;
    state ^= state << 5;
    return float(state) / 4294967296.0;
}

// 简单着色：lambert + 环境光
vec3 shade(Ray ray)
{
    HitInfo bestHit;
    bestHit.t = 1e20;
    bestHit.index = -1;
    bestHit.normal = vec3(0.0);

    for (int i = 0; i < uSphereCount; ++i)
    {
        HitInfo h;
        if (intersectSphere(ray, spheres[i], h))
        {
            if (h.t < bestHit.t)
            {
                bestHit = h;
                bestHit.index = i;
            }
        }
    }

    if (bestHit.index < 0)
    {
        // miss，天空色
        vec3 skyTop = vec3(0.5, 0.7, 1.0);
        vec3 skyBottom = vec3(0.2, 0.2, 0.25);
        float t = 0.5 * (ray.dir.y + 1.0);
        return mix(skyBottom, skyTop, t);
    }

    Sphere s = spheres[bestHit.index];
    vec3 color = s.colorEmission.xyz;
    float emission = s.colorEmission.w;

    vec3 hitPos = ray.origin + bestHit.t * ray.dir;
    vec3 N = normalize(bestHit.normal);
    vec3 L = normalize(vec3(1.0, 1.0, -0.5));   // 主光方向
    float NdotL = max(dot(N, L), 0.0);

    vec3 diffuse = color * NdotL;
    vec3 ambient = color * 0.1;

    vec3 result = diffuse + ambient;

    // 简单自发光（如果你想做灯光球）
    result += emission * color;

    return result;
}

void main()
{
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    if (pix.x >= uWidth || pix.y >= uHeight) return;

    // 像素中心坐标 [0,1]
    float sx = (float(pix.x) + 0.5) / float(uWidth);
    float sy = (float(pix.y) + 0.5) / float(uHeight);

    // 转到 [-1,1]
    float ndcX = sx * 2.0 - 1.0;
    float ndcY = sy * 2.0 - 1.0;

    float aspect = float(uWidth) / float(uHeight);
    float scale = tan(radians(uFov * 0.5));

    vec3 dir = normalize(
        uCamForward
        + ndcX * aspect * scale * uCamRight
        - ndcY * scale * uCamUp
    );

    Ray ray;
    ray.origin = uCamPos;
    ray.dir = dir;

    vec3 col = shade(ray);

    imageStore(uOutput, pix, vec4(col, 1.0));
}
